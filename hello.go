package leanfactory

//-------------------------------
// Dependencies
//-------------------------------
import (
        "encoding/json"
        "html/template"
        "net/http"
        "net/url"
        "log"
        "fmt"

        "appengine"
        "appengine/memcache"
        "appengine/urlfetch"
)

//-------------------------------
// Constants and templates
//-------------------------------

const (
    //OxfordDictionaries API 
    APPLICATION_ID = ""
    APPLICATION_KEY = ""
)

var homeTemplate = template.Must(template.ParseFiles(
    "html/home.html"))

//-------------------------------
// Structures
//-------------------------------

type Entry struct  {
    Word string
    Definition string
}

type AutoGenerated struct {
    Metadata struct {
        Provider string `json:"provider"`
    } `json:"metadata"`
    Results []struct {
        ID             string `json:"id"`
        Language       string `json:"language"`
        LexicalEntries []struct {
            Entries []struct {
                GrammaticalFeatures []struct {
                    Text string `json:"text"`
                    Type string `json:"type"`
                } `json:"grammaticalFeatures"`
                HomographNumber string `json:"homographNumber"`
                Senses          []struct {
                    Definitions []string `json:"definitions"`
                    Examples    []struct {
                        Text string `json:"text"`
                    } `json:"examples"`
                    ID        string   `json:"id"`
                    Registers []string `json:"registers"`
                } `json:"senses"`
                VariantForms []struct {
                    Text string `json:"text"`
                } `json:"variantForms"`
            } `json:"entries"`
            Language        string `json:"language"`
            LexicalCategory string `json:"lexicalCategory"`
            Text            string `json:"text"`
        } `json:"lexicalEntries"`
        Type string `json:"type"`
        Word string `json:"word"`
    } `json:"results"`
}

//-------------------------------
// Functions
//-------------------------------

func init() {
        http.HandleFunc("/", root)
        http.HandleFunc("/search", search)
        http.Handle("/dist/", http.StripPrefix("/dist/", http.FileServer(http.Dir("dist"))))
        http.Handle("/docs/", http.StripPrefix("/docs/", http.FileServer(http.Dir("docs")))) 

}

func root(w http.ResponseWriter, r *http.Request) {
    //Apply template with a nil struct, its probably not ok but Golang is a mystery
    if err := homeTemplate.Execute(w, nil); err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}

func search(w http.ResponseWriter, r *http.Request) {

        c := appengine.NewContext(r)
        //Escape the string
        params := url.QueryEscape(r.FormValue("content"))
        //Build the URL
        url := fmt.Sprintf("https://od-api.oxforddictionaries.com/api/v1/entries/en/%s", params)

        //First seach for the key in cache else from the api
        definition := searchInCache(c, params)
        word := Entry{params, definition}

        //Else retrieve from the API
        if definition == "" {
            //HTTP Request
            client := &http.Client{
                Transport: &urlfetch.Transport{Context: c},
            }
            req, error := http.NewRequest("GET", url, nil)
            req.Header.Add("app_id", APPLICATION_ID)
            req.Header.Add("app_key", APPLICATION_KEY)
            resp, error := client.Do(req)
            if error != nil {
                log.Println("An error occurred making the request")
                word = Entry{params, "HTTP ERROR"}
            }
            defer resp.Body.Close()

            //Parse the response if there is a definition
            var respuesta AutoGenerated
            if errorDecoding := json.NewDecoder(resp.Body).Decode(&respuesta); errorDecoding != nil {

                log.Println("An error ocurred while decoding the response")
                word = Entry{params, "No results found"}

            } else {
                
                definition = respuesta.Results[0].LexicalEntries[0].Entries[0].Senses[0].Definitions[0]
                word = Entry{params, definition}
            
                //Store the result in cache
                saveInCache(c, params, respuesta)                
            }

        }

        if err := homeTemplate.Execute(w, word); err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
        }

}

//Search using a key in cache
func searchInCache(c appengine.Context, word string) string {

    if item, err := memcache.Get(c, word); err == memcache.ErrCacheMiss {
        log.Println("Not cached")
    } else if err != nil {
        log.Println("error getting item: ", err)
    } else {
        return string(item.Value)
    }
    return ""
}

//Store a definition in cache
func saveInCache(c appengine.Context, word string, respuesta AutoGenerated) {
    //For now I will only store the first definition
    item := &memcache.Item{
        Key: word,
        Value: []byte(respuesta.Results[0].LexicalEntries[0].Entries[0].Senses[0].Definitions[0]),
    }
    memcache.Add(c, item)

}
